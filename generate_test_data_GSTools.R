#' @title Generate test-data
#' @description function that utilizes the original dataset, the centers of the model to be analysed and
#' weather information to create a test-data set that will be scaled and read to use in posteriror evaluations
#' @observation If wt_t.Rdata is null all cells will be scalled and outputed, if wt_f is filled with the köppen geiger
#' climate classification generated by the file: köppen_geiger_pre_processing.R.

generate_test_data = function(input_data, center_mean, center_stddev, grid, weather_dataset, wt_f=NULL, scaled = T, soil_type = NULL, points=NULL){
  #excluding greenland and antarctica from the analysis
  
  if(is.null(soil_type)){
    environmental_var = weather_dataset[,c(1,3,5)]
  }else{
    environmental_var = cbind(weather_dataset[,c(1,3,5)],soil_type)
  }
  
  if(is.null(wt_f)){
    df.combined = cbind(input_data,grid,environmental_var)
  }else{
    dummy.x = cbind(input_data,grid,environmental_var,wt_f)
    df.combined = dummy.x[which(dummy.x$Cls != "EF" & dummy.x$Cls != "ET"),c(1:17)]
    print("EF and ET climates removed from analysis")
  }
  
  if(!is.null(points)){
    df.combined = df.combined[,-c(1:ncol(input_data))]
    df.combined = data.frame(points,df.combined)
    colnames(df.combined)[1:length(points)] =  points
    print("Orginal data points substituted by list")
  }
  
# harvest[,-c(1:ncol(input_data))]
  df.long = df.combined %>% gather(key = "LSU","lon":"soil_type",-c("lon":"soil_type"))
  colnames(df.long)[ncol(df.long)] = "gCm2"
  df.long$LSU = as.numeric(df.long$LSU)/10


  
  if(is.null(soil_type)){
    test_data = df.long[,1:6]
  }else{
    test_data = df.long[,1:7]
  }
  
  test_data = as.matrix(test_data)

  if(scaled){
  ###Standardizing the test data###
  test_data <- scale(test_data, center = center_mean, scale = center_stddev)
  return(test_data) 
  }else{
  return(test_data)   
  }
}